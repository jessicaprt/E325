public class GenericRedBlackTree<Key extends Comparable<Key>, Value> {

	class Node<Key extends Comparable<Key>, Value> {
		private Key key;
		private Value data;
		public Node right;
		public Node left;
		public Node parent;
		public int colour;

		public Node(Key k, Value v) {
			this.key = k; 
			this.data = v; 
		}

		public void addNode(Node<Key, Value> newNode) {
			if (newNode.getKey().compareTo(key) == 1) {
				if (right == null) {
					right = newNode;
					right.parent = this;
				} else {
					right.addNode(newNode);
				}
			} else if (newNode.getKey().compareTo(key) == -1) {
				if (left == null) {
					left = newNode;
					left.parent = this;
				} else {
					left.addNode(newNode);
				}
			}
		}

		Value getVal() {
			return this.data;
		}

		public Key getKey() {
			return this.key;
		}

		void setVal(Value v) {
			this.data = v;
		}

		void setKey(Key k) {
			this.key = k;
		}

		public Node<Key, Value> sibling() {
		    assert parent != null;
		    if (this == parent.left)
		        return parent.right;
		    else
		        return parent.left;
		}
	}

	Node<Key, Value> root;

	static int BLACK = 0;
	static int RED = 1;

	public GenericRedBlackTree() {
		root = new Node(null, null);
		root.right = root.left = null;
	}

	int colour(Node<Key, Value> n) {
		return (n == null) ? BLACK : n.colour; 
	}

	void rotateleft(Node<Key, Value> n) {
		Node saveP = n.parent;
		Node saveN = n.left;
		Node saveC = saveN.right;

		saveN.parent = saveP;
		if (saveP != null) {
			saveP.left = saveN;
		}

		n.parent = saveN;
		saveN.right = n;

		n.left = saveC;
		if (saveC != null) {
			saveC.parent = n;
		}

		Node node = n;
		while (node.parent != null) {
			node = node.parent;
		}
		root = node;
	}

	void rotateright(Node<Key, Value> n) {
		Node saveP = n.parent;
		Node saveN = n.right;
		Node saveC = saveN.left;

		saveN.parent = saveP;
		if (saveP != null) {
			saveP.right = saveN;
		}

		n.parent = saveN;
		saveN.left = n;

		n.right = saveC;
		if (saveC != null) {
			saveC.parent = n;
		}

		Node node = n;
		while (node.parent != null) {
			node = node.parent;
		}
		root = node;
	}

	void rotateRight(Node<Key, Value> n) {
	    Node<Key,Value> l = n.left;
	    replaceNode(n, l);
	    n.left = l.right;
	    if (l.right != null) {
	        l.right.parent = n;
	    }
	    l.right = n;
	    n.parent = l;
	}
	
	void rotateLeft(Node<Key, Value> n) {
	    Node<Key,Value> r = n.right;
	    replaceNode(n, r);
	    n.right = r.left;
	    if (r.left != null) {
	        r.left.parent = n;
	    }
	    r.left = n;
	    n.parent = r;
	}
	
	void insert_case_5(Node<Key, Value> child) {
		Node parent = child.parent;
		Node grandParent = parent.parent;

		parent.colour = BLACK;
		grandParent.colour = RED;
		if (child == parent.right) {
			rotateright(grandParent);
		} else {
			rotateleft(grandParent);
		}
	}

	void insert_case_4(Node<Key, Value> child) {
		Node parent = child.parent;
		Node grandParent = parent.parent;

		if (child == parent.left && parent == grandParent.right) {
			rotateleft(child);
			child = child.right;
		} else if (child == parent.right && parent == grandParent.left) {
			rotateright(child);
			child = child.left;
		}
		insert_case_5(child);
	}

	void insert_case_3(Node<Key, Value> child) {
		Node parent = child.parent;
		Node grandParent = parent.parent;
		Node uncle;
		if (grandParent.right == parent) {
			uncle = grandParent.left;
		} else {
			uncle = grandParent.right;
		}

		if (uncle != null && uncle.colour == RED) {
			child.parent.colour = BLACK;
			uncle.colour = BLACK;
			grandParent.colour = RED;
			insert_case_1(grandParent);
		} else {
			insert_case_4(child);
		}
	}

	void insert_case_2(Node<Key, Value> child) {
		if (child.parent.colour == BLACK) {
			return;
		} else {
			insert_case_3(child);
		}
	}

	void insert_case_1(Node<Key, Value> child) {
		if (child.parent == null) {
			child.colour = BLACK;
		} else {
			child.colour = RED;
			insert_case_2(child);
		}
	}

	void insert(Key x, Value y) {
		Node newNode = new Node(x,y);

		newNode.setKey(x);
		newNode.setVal(y);

		newNode.right = null;
		newNode.left = null;

		if (root.getVal() == null) {
			root = newNode;
		} else {
			root.addNode(newNode);
		}

		insert_case_1(newNode);
	};

	void delete_case_6(Node<Key, Value> n) {
		n.sibling().colour = n.parent.colour; 
		n.parent.colour = BLACK; 
		if (n == n.parent.left) {
			assert n.sibling().right.colour == RED; 
			n.sibling().right.colour = BLACK; 
			rotateLeft(n.parent);
		} else {
			assert n.sibling().left.colour == RED; 
			n.sibling().left.colour = BLACK; 
			rotateRight(n.parent); 
		}
	}
	
	void delete_case_5(Node<Key, Value> n) {
		if (n == n.parent.left && 
				colour(n.sibling()) == BLACK &&  
				colour(n.sibling().right) == BLACK &&
				colour(n.sibling().left) == RED) {
	        n.sibling().colour = RED;
	        n.sibling().left.colour = BLACK;
	        rotateRight(n.sibling());
	    }
		else if (n == n.parent.right && colour(n.sibling()) == BLACK && colour(n.sibling().right) == RED && colour(n.sibling().left) == BLACK) {
	        n.sibling().colour = RED;
	        n.sibling().right.colour = BLACK;
	        rotateLeft(n.sibling());
	    } else delete_case_6(n);
	}
	
	void delete_case_4(Node<Key, Value> n) {
		if (colour(n.parent) == RED && colour(n.sibling()) == BLACK && colour(n.sibling().left) == BLACK && colour(n.sibling().right) == BLACK) {
			n.sibling().colour = RED; 
			n.parent.colour = BLACK; 
		} else delete_case_5(n); 
	}
	
	void delete_case_3(Node<Key, Value> n) {
		if (colour(n.parent) == BLACK && colour(n.sibling()) == BLACK && colour(n.sibling().left) == BLACK && colour(n.sibling().right) == BLACK) {
			n.sibling().colour = RED; 
			delete_case_1(n.parent); 
		} else delete_case_4(n); 
	}
	
	void delete_case_2(Node<Key, Value> n) {
		if (colour(n.sibling()) == RED) {
			n.parent.colour = RED; 
			n.sibling().colour = BLACK; 
			if (n == n.parent.left) {
				rotateLeft(n.parent); 
			} else {
				rotateRight(n.parent); 
			}
		}
		delete_case_3(n); 
	}

	void delete_case_1(Node<Key, Value> n) {
		if (n.parent == null) {
			return; 
		} else delete_case_2(n); 
	}
	
	void delete(Node<Key, Value> n) {
		if (n == null) {
			return; 
		}
		if (n.left != null && n.right != null) {
			Node<Key, Value> pred = maximumNode(n.left); 
			n.setKey(pred.getKey());
			n.setVal(pred.getVal());
			n = pred; 
		}
		
		assert n.left == null || n.right == null; 
		Node<Key, Value> child = (n.right == null) ? n.left : n.right;
		int parentColour = n.colour; 
		
//		replaceNode(n, child); 
//		if(parentColour == BLACK) {
//			if (colour(n) == RED) {
//				n.colour = BLACK; 
//			} else delete_case_1(n); 
//		}
		if (n.colour == BLACK) {
			n.colour = (child == null) ? BLACK : child.colour; 
			delete_case_1(n); 
		}
		replaceNode(n, child);
	}
	void delete(Key k) {
		delete(findNode(k));
	}

	Node<Key, Value> maximumNode(Node<Key, Value> n) {
		assert n != null; 
		while (n.right != null) {
			n = n.right; 
		}
		return n;
	}

	void replaceNode(Node<Key, Value> oldn, Node<Key, Value> newn) {
		if (oldn.parent == null) {
			root = newn;
		} else {
			if (oldn == oldn.parent.left) {
				oldn.parent.left = newn; 
			} else oldn.parent.right = newn; 
		}
		if (newn != null) {
			newn.parent = oldn.parent; 
		}
	}
	
	Node<Key, Value> findNode(Key k) {
		return findNode(k, root);
  	}
	Node<Key, Value> findNode(Key k, Node<Key, Value> n) {
		while (n != null){
			int cmp = k.compareTo((Key) n.getKey());
			if (cmp < 0){
				n = n.left;
			} else if ( cmp > 0){
				n = n.right;
			} else return n;
		}
		return null;
	}

	boolean isEmpty() {
		return root.getVal() == null;
	}

	void clearTree() {
		root.right = null;
		root.left = null;
		root.setKey(null);
	}

	void printTree() {
		printTree(root);
	}
	void printTree(Node n) {
		if (n != null) {
			printTree(n.left);
			System.out.println(n.getKey() + " " + n.getVal() + " " + n.colour);
			printTree(n.right);
		}
	}

	public static void main(String[] args) {
		GenericRedBlackTree<Integer, String> GenericRedBlackTree = new GenericRedBlackTree<Integer, String>();
		GenericRedBlackTree.insert(4, "a");
		GenericRedBlackTree.insert(2, "b");
		GenericRedBlackTree.insert(1, "c");
		GenericRedBlackTree.insert(3, "d");
		GenericRedBlackTree.insert(6, "e");
		GenericRedBlackTree.insert(5, "f");

		GenericRedBlackTree.printTree();
		
		GenericRedBlackTree.delete(6);
		GenericRedBlackTree.delete(5);
		GenericRedBlackTree.delete(4);
		GenericRedBlackTree.delete(3);
		GenericRedBlackTree.delete(2);
		GenericRedBlackTree.delete(1);

		GenericRedBlackTree.printTree();
	}

}
